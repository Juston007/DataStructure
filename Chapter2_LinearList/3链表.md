# 线性链表
链式存储结构不要求逻辑上相邻的元素在物理位置上也相邻，因此他没有顺序存储结构所具有的缺点，但同时也失去了顺序表可随机存取的优点

# 特点
用一组任意的存储单元存储线性表的数据元素

这组存储单元可以是连续的，也可以是不连续的

因此，为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对于数据元素ai来说除了存储器本身的信息还需要存储指示其直接后继的信息

这两部分信息组成数据元素ai的存储映像，称为结点（node）

它包括两个域：
* 数据域；存储数据元素信息的域
* 指针域；存储直接后继存储位置的域

指针域中存储的信息称作指针或链

n个结点链结成一个链表，即为线性表的链式存储结构
* (a1, a2, ..., an)

因为只包含一个指针域，又称为单链表

整个链表的存取必须从头指针开始进行，头指针指示链表中第一个元素

同时，因为最后一个元素没有直接后继，则线性链表中最后一个结点的指针域为“NULL”

# 链表获取元素
时间复杂度 O(n)

因为其存储结构的特点，不能像顺序表那样随意访问

只能从头结点开始，通过结点的指针域访问其直接后继，直到找到目的下标的结点
```
ElementType getElement(LinkedList list,int index){

    //首先指向头节点
    LinkedNode *element = list;

    //循环几次就指向第几个元素
    //从0到index(用户要找的下标)
    for(int i = 0;i <= index;i++){
        //还没找到index的元素
        //但是当前元素为空 直接返回ERROR
        if(element == NULL)
            return NULL;

        //指向下一个元素
        element = element->next;
    }

    //返回下标为index的元素值
    retrun element->data;
}
```

# 链表插入元素
跟顺序表相比，链表插入元素时不需要后移元素，只需要修改结点的指针即可

所以其插入时的时间复杂度更底，为O(1)

Code
```
Status insertElement(LinkedList &list,int index,ElementType newElement){

    //下标[index]不合法
    if(index < 0 || index > getLength(linkedList)){
        return INFEASIBLE;
    }

    //先指向头节点
    LinkedNode *element = list;

    //指向第[i - 1]个元素
    for(int i = 0;i <= (index - 1);i++){
        //当前元素为空 直接返回ERROR
        if(element == NULL)
            return ERROR;

        //指向下一个元素
        element = element->next;
    }

    //申请新节点的内存
    LinkedNode *newNode = (LinkedNode *)malloc(sizeof(LinkedNode));

    //如果新节点分配空间失败 那么直接exit
    if(newNode == NULL)
        exit(1);

    newNode->data = newElement;

    //新结点的下一个结点是下标为[index-1]元素的下一个[index]结点
    newNode->next = element->next;

    //新节点是下标为[index - 1]元素的后继
    element->next = newNode;

    return OK;
}
```

# 链表删除元素
```
```

# 链表合并
```
```

# 循环链表

# 双向链表