# 队列（Queue）
和栈相反，队列是一种先进先出（first in first out，缩写为FIFO）的线性表

它只允许在表的一端进行插入，而在表的另一端删除元素；

在队列中
* 队尾（rear）；允许插入的一端叫做队尾
* 队头（front）；允许删除的一端叫做队头

抽象数据类型定义：
```
ADT Queue {
    数据对象：D={ai|ai∈ElementSet, i = 1,2,...,}

    数据关系：R1={<ai-1,ai>|ai-1,ai∈D,i=2,...,n}

    基本操作：

    //初始化队列
    Status InitQueue(Queue);

    //销毁队列
    Status DestoryQueue(Queue);

    //清空队列
    Status ClearQueue(Queue);

    //是否为空队列
    boolean isEmptyQueue(Queue);

    //获取队列长度
    int QueueLength(Queue);

    //获取队头
    ElementType GetHead(Queue);

    //入列
    Status EnQueue(Queue, 
    ElementType element);

    //出列
    ElementType DeQueue(Queue);

    //遍历队列
    void TraverseQueue(Queue);
}
```

# 链式队列
用链表表示的队列简称为链队列

一个链队列显然需要两个分别指向队头和队尾的指针（分别称为队头指针和队尾指针）才能唯一确定；

空的链队的判决条件为头指针和尾指针均指向头结点

```
/**队列结点**/
typedef struct QueueNode {
    QueueElementType    data;   //数据
    struct QueueNode    *next;  //指针
} QueueNode, *QueuePointer;


/**队列**/
typedef struct {
    QueuePointer    front;      //队头指针
    QueuePointer    rear;       //队尾指针
} LinkedQueue;
```

# 循环队列
在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尚需附设两个指针front和rear分别指示队列头元素以及队列尾元素的位置；

因此，在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一位置

一个大小为6的队列（下标从0开始），队头为4，头尾为5，此时不能再继续插入新的队尾元素，否则会数组越界；

解决办法是臆造为一个环状的空间，称之为循环队列

```
typedef struct {
    QueueElementType    *base;  //初始化的空间
    int                 front;  //头指针；若队列不空，则指向队列头元素
    int                 rear;   //尾指针；若队列不空，则指向队尾元素的下一位置
} SequenceQueue;
```
## 牺牲一个存储空间构造的循环队列
* 队满 (rear + 1) % size == front
* 队空 front == rear
* 队列长度 (rear - front + size) % size